# 3D Reconstruction Service Interface

This document defines the contract between the iOS backend (`server/app`) and the external 3D reconstruction service that will replace the current status simulator. It focuses on the minimum feature set required to submit photo batches, track progress, and retrieve generated model artifacts.

## Overview

```
iOS client ──► FastAPI backend ──► Reconstruction service
                                ▲
                                └── status + artifact callbacks
```

- The FastAPI backend remains the single entry point for mobile clients: it authenticates users, stores uploads in PostgreSQL, and handles authorization.
- The reconstruction service is responsible for running Structure-from-Motion / MVS pipelines on uploaded photo sets and producing downloadable 3D models.
- Communication between backend and reconstruction service happens over HTTP (can be internal network) using bearer tokens.

## Authentication

All requests between backend and reconstruction service use a shared bearer token:

- Backend → reconstruction service: `Authorization: Bearer <RECON_SERVICE_TOKEN>`
- Reconstruction service → backend callbacks: `Authorization: Bearer <RECON_CALLBACK_TOKEN>`

Both tokens are configured via environment variables on the respective services. The backend rejects callback requests without the expected token.

## Endpoints exposed by the reconstruction service

### `POST /jobs`

Submit a new reconstruction job.

| Field             | Type              | Description                                               |
|-------------------|-------------------|-----------------------------------------------------------|
| `job_id`          | `string (UUID)`   | UUID generated by the backend; used as idempotency key.   |
| `dataset_name`    | `string`          | Human-readable project name.                              |
| `photo_count`     | `integer`         | Number of images included.                                |
| `photos_dir`      | `string`          | Absolute path to the directory containing uploaded JPEGs. |
| `notes`           | `string?`         | Optional notes supplied by the user.                      |

**Response**

```json
{
  "accepted": true,
  "external_job_id": "string | null",
  "message": "queued"
}
```

- `external_job_id` can be omitted if the service uses the backend-provided UUID.
- On error return HTTP 400/500 with a JSON body `{ "error": "..." }`; the backend translates this into a failed upload.

### `GET /jobs/{job_id}`

Query status for a job (used if polling is required).

```json
{
  "status": "queued|processing|meshing|texturing|completed|failed",
  "progress": 0.0,
  "message": "optional human-readable detail",
  "model_uri": "s3://bucket/key.glb | file:///path/to/model | null"
}
```

- `model_uri` becomes non-null when the reconstructed model is ready.

### `POST /jobs/{job_id}/cancel` *(optional)*

Allow backend or admin tooling to cancel jobs.

## Callbacks that the reconstruction service must invoke

If the service supports callbacks, it should notify the backend instead of being polled.

### `POST /internal/reconstruction/status`

Called whenever the job transitions to a new state.

```json
{
  "job_id": "UUID",
  "status": "queued|processing|meshing|texturing|completed|failed",
  "progress": 0.0,
  "message": "optional note",
  "model_uri": "file:///path/to/model | s3://... | null"
}
```

- Backend validates the token, then maps this to `AppStateStore.update_job`.
- When `status == "completed"` and `model_uri` points to the generated artifact, backend downloads or copies the file into `data/models/<job_id>/` and stores the filename in `model_file_name`.
- For failure cases the backend records the message and switches the job to `failed`.

### `POST /internal/reconstruction/progress` *(optional)*

Allows high-frequency progress updates without toggling status. Same body as above but optional fields `status`, `progress`.

## File storage expectations

- Backend saves uploaded JPEGs under `data/uploads/<job_id>/photo_#.jpg`. `photos_dir` points to this directory.
- The reconstruction service may either read the files directly (if sharing the same filesystem) or require the backend to upload them to shared storage (S3, GCS). If remote storage is required, the service interface must return a pre-signed upload location during `POST /jobs`.
- Generated models must be written to a location accessible by the backend. For local development this is `data/models/<job_id>/<artifact>`.

## Error handling

- If `POST /jobs` fails (network or non-2xx), the backend marks the upload as failed immediately and surfaces the message to the user.
- If callbacks are used, the reconstruction service should retry failed notifications with exponential backoff. Backend endpoints are idempotent; repeated delivery for the same payload is safe.
- The backend exposes `/jobs/{job_id}/status` to the client; ensure that the callback or polling pathway updates both `status` and `progress` to keep the UI consistent.

## Configuration summary

| Variable | Purpose |
|---------|---------|
| `RECON_SERVICE_URL` | Base URL for backend to call (e.g., `http://localhost:9000`). |
| `RECON_SERVICE_TOKEN` | Bearer token used for backend → service requests. |
| `RECON_CALLBACK_TOKEN` | Bearer token service must send when calling backend callbacks. |
| `MODEL_OUTPUT_ROOT` | Filesystem location where backend stores retrieved models. |

## Next steps

1. Implement an HTTP client in `server/app/services/reconstruction_client.py` (new file) using the contract above.
2. Replace `StatusSimulator.schedule(...)` with logic that enqueues the job via `POST /jobs` and stores the returned `external_job_id`.
3. Add callback endpoints in FastAPI (`/internal/reconstruction/status`) to update the job via `AppStateStore`.
4. Provide a mock implementation of the reconstruction service for local testing until the real algorithm is ready.
